"""Tests for write_source_files"""
# Inspired by https://github.com/cgrindel/bazel-starlib/blob/main/updatesrc/private/updatesrc_update_test.bzl

load("//lib/private:directory_path.bzl", "DirectoryPathInfo")
load("//lib/private:write_source_file.bzl", _write_source_file = "write_source_file")
load("//lib:windows_utils.bzl", "BATCH_RLOCATION_FUNCTION")
load("//lib:paths.bzl", "BASH_RLOCATION_FUNCTION", "to_rlocation_path")

def _write_source_file_test_impl_sh(ctx, in_file_path, out_file_path, out_short_path):
    test = ctx.actions.declare_file(
        ctx.label.name + "_test.sh",
    )

    contents = []

    contents.append("""
#!/usr/bin/env bash
set -o errexit -o nounset -o pipefail
""")

    contents.append(BASH_RLOCATION_FUNCTION)

    contents.append("""
assert_different() {
  diff  "${1}" "${2}" > /dev/null && (echo >&2 "Expected files to differ. in: ${1}, out: ${2}" && return -1)
  return 0
}

assert_same() {
  diff  "${1}" "${2}" || (echo >&2 "Expected files to be same. in: ${1}, out: ${2}" && return -1)
}""")

    contents.append("""
# use rlocation for in_file and original state of out_file
in_path="$(rlocation {in_file})"
out_file_orig="$(rlocation {out_file_orig})"
# out_path may be in runfiles (test) or workspace (run)
out_path={out_short_path}
# remap out_path to workspace if invoked by bazel run
if [[ ! -z "${{BUILD_WORKSPACE_DIRECTORY:-}}" ]]; then
    out_path="${{BUILD_WORKSPACE_DIRECTORY}}/${{out_path}}"
fi
""".format(
        in_file = in_file_path,
        out_file_orig = out_file_path,
        out_short_path = out_short_path,
    ))

    contents.append("""
# Check that in and original out files are different
assert_different $in_path $out_file_orig
""")

    contents.append("""# Write to the source files
$(rlocation {write_source_files})
""".format(write_source_files = to_rlocation_path(ctx, ctx.executable.write_source_file_target)))

    contents.append("""# Check that in and out files are the same
assert_same $in_path $out_path""")

    ctx.actions.write(
        output = test,
        is_executable = True,
        content = "\n".join(contents),
    )

    return test

def _write_source_file_test_impl_bat(ctx, in_file_path, out_file_path, out_short_path):
    test = ctx.actions.declare_file(
        ctx.label.name + "_test.bat",
    )

    write_source_files = to_rlocation_path(ctx, ctx.executable.write_source_file_target)

    contents = []

    contents.append("""
@rem @generated by @aspect_bazel_lib//:lib/tests/write_source_files:write_source_file_test.bzl
@echo off
SETLOCAL ENABLEEXTENSIONS
SETLOCAL ENABLEDELAYEDEXPANSION
set RUNFILES_MANIFEST_ONLY=1
@rem use rlocation for in_file and original state of out_file
call :rlocation {in_file} in_path
call :rlocation {out_file_orig} out_path_orig
@rem out_file may be in runfiles (test) or workspace (run)
set out_path={out_short_path}
@rem remap out_path to workspace if invoked by bazel run
if defined BUILD_WORKSPACE_DIRECTORY (
    set out_path=%BUILD_WORKSPACE_DIRECTORY%\\%out_path%
)
@rem Check that in and out files are different
call :assert_different %in_path% %out_path_orig%
if %errorlevel% neq 0 exit /b 1
""".format(
        in_file = in_file_path,
        out_file_orig = out_file_path,
        out_short_path = out_short_path.replace("/", "\\"),
    ))

    contents.append("""
@rem if invoked by bazel test --noenable_runfiles, create the outdir
for %%F in ("%out_path%") do set "out_dir=%%~dpF"
if not exist %out_dir% (
    mkdir %out_dir%
)
@rem Write to the source files
call :rlocation {write_source_files} write_source_files_path
call %write_source_files_path%
if %errorlevel% neq 0 exit /b 1
""".format(
        write_source_files = write_source_files
    ))

    contents.append("""
@rem Check that in and out files are the same
call :assert_same %in_path% %out_path%
if %errorlevel% neq 0 exit /b 1
""")

    contents.append("""
exit /b 0

:assert_different
fc /b %~1 %~2 > nul
if %errorlevel% equ 1 exit /b 0
echo Error: %~1 and %~2 are not different
exit /b 1

:assert_same
fc /b %~1 %~2 > nul
if %errorlevel% equ 0 exit /b 0
echo Error: %~1 and %~2 are not the same
exit /b 1
""")

    contents.append(BATCH_RLOCATION_FUNCTION)

    ctx.actions.write(
        output = test,
        is_executable = True,
        content = "\n".join(contents).replace("\n", "\r\n"),
    )

    return test

def _write_source_file_test_impl(ctx):
    is_windows = ctx.target_platform_has_constraint(ctx.attr._windows_constraint[platform_common.ConstraintValueInfo])

    if DirectoryPathInfo in ctx.attr.in_file:
        in_file = ctx.attr.in_file[DirectoryPathInfo].directory
        in_file_path = "/".join([to_rlocation_path(ctx, in_file), ctx.attr.in_file[DirectoryPathInfo].path])
    else:
        if len(ctx.files.in_file) != 1:
            fail("in_file must be a single file or a target that provides a DirectoryPathInfo")
        in_file = ctx.files.in_file[0]
        in_file_path = to_rlocation_path(ctx, in_file)

    out_file_path = to_rlocation_path(ctx, ctx.file.out_file)
    out_short_path = ctx.file.out_file.short_path
    if is_windows:
        test = _write_source_file_test_impl_bat(ctx, in_file_path, out_file_path, out_short_path)
    else:
        test = _write_source_file_test_impl_sh(ctx, in_file_path, out_file_path, out_short_path)

    return DefaultInfo(
        executable = test,
        runfiles = ctx.runfiles(
            files = [ctx.executable.write_source_file_target, in_file, ctx.file.out_file] + ctx.files._bash_runfiles,
        ),
    )

_write_source_file_test = rule(
    implementation = _write_source_file_test_impl,
    attrs = {
        "write_source_file_target": attr.label(
            allow_single_file = True,
            executable = True,
            # Intentionally use the target platform since the target is always meant to be `bazel
            # run` on the host machine but we don't want to transition it to the host platform and
            # have the generated file rebuilt in a separate output tree. Target platform should
            # always be equal to the host platform when using `write_source_files`.
            cfg = "target",
            mandatory = True,
        ),
        "out_file": attr.label(
            allow_single_file = True,
            mandatory = True,
        ),
        "in_file": attr.label(
            allow_files = True,
            mandatory = True,
        ),
        "_bash_runfiles": attr.label(
            default = Label("@bazel_tools//tools/bash/runfiles"),
        ),
        "_windows_constraint": attr.label(
            default = "@platforms//os:windows"
        ),
    },
    test = True,
)

def write_source_file_test(name, in_file, out_file, check_that_out_file_exists = True):
    """Stamp a write_source_files executable and a test to run against it"""

    _write_source_file(
        name = name + "_updater",
        in_file = in_file,
        out_file = out_file,
        diff_test = False,
        check_that_out_file_exists = check_that_out_file_exists,
    )

    # Note that for testing we update the source files in the sandbox,
    # not the actual source tree.
    _write_source_file_test(
        name = name,
        write_source_file_target = name + "_updater",
        in_file = in_file,
        out_file = out_file,
        timeout = "short",
    )
